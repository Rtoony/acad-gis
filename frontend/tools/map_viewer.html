<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Map Viewer | ACAD-GIS</title>
  <link rel="stylesheet" href="../shared/styles.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://unpkg.com/proj4@2.9.2/dist/proj4.js"></script>
  <script src="https://unpkg.com/proj4leaflet@1.0.2/src/proj4leaflet.js"></script>
  <style>
    #map { height: calc(100vh - 260px); border-radius: 12px; }
    .toolbar { display:flex; gap: 12px; align-items:center; }
    .statusbar { display:flex; justify-content:space-between; color: var(--color-text-secondary); font-size: 0.85rem; padding-top: 8px; }
    .input, select.input { background: rgba(15,23,42,0.8); color: #e0e7ff; border: 1px solid rgba(59,130,246,0.35); padding: 6px 10px; border-radius: 8px; }
    .sep { width:1px; height:24px; background: rgba(59,130,246,0.35); }
    .map-wrapper { position: relative; }
    .map-legend { position: absolute; bottom: 16px; right: 16px; background: rgba(15,23,42,0.88); padding: 12px 14px; border-radius: 12px; box-shadow: 0 12px 24px rgba(15,23,42,0.55); color: #e0e7ff; max-width: 220px; min-width: 180px; z-index: 500; font-size: 0.9rem; pointer-events: auto; }
    .map-legend h4 { margin: 0 0 8px; font-size: 0.9rem; font-weight: 600; letter-spacing: 0.02em; text-transform: uppercase; color: rgba(226,232,240,0.92); }
    .legend-item { display: flex; align-items: center; gap: 10px; margin-bottom: 6px; }
    .legend-item:last-child { margin-bottom: 0; }
    .legend-swatch { width: 18px; height: 18px; border-radius: 4px; border: 1px solid rgba(226,232,240,0.35); box-shadow: inset 0 0 4px rgba(15,23,42,0.45); }
    .legend-label { flex: 1; display: flex; flex-direction: column; gap: 2px; }
    .legend-muted { color: rgba(148,163,184,0.85); font-size: 0.78rem; letter-spacing: 0.01em; }
  </style>
</head>
<body class="grid-background">
  <div id="root"></div>

  <script src="../shared/components.js"></script>
  <script src="../shared/react-components.js"></script>
  <script src="../shared/api.js"></script>
  <script type="text/babel">
    const { useEffect, useRef, useState, useMemo, useCallback } = React;
    const HeaderComp = window.Header || (({ title, subtitle }) => (
      React.createElement('header', { className: 'header' },
        React.createElement('div', { className: 'header-content' },
          React.createElement('div', { className: 'header-title' },
            React.createElement('h1', null, title || 'Map Viewer'),
            subtitle && React.createElement('div', { className: 'header-subtitle' }, subtitle)
          )
        )
      )
    ));

    const FEATURE_STYLE = {
      line: { color: '#22d3ee', weight: 2 },
      polygon: { color: '#a855f7', weight: 1.2, fillColor: '#a855f7', fillOpacity: 0.18 },
      symbol: { color: '#2563eb', radius: 6 },
      point: { color: '#10b981', radius: 4 },
      label: { color: '#f97316', radius: 5 }
    };

    const DEFAULT_COLOR = '#22d3ee';
    const DEFAULT_FILL_ALPHA = 0.18;
    const ACI_COLORS = {
      1: '#ff0000',
      2: '#ffff00',
      3: '#00ff00',
      4: '#00ffff',
      5: '#0000ff',
      6: '#ff00ff',
      7: '#f8fafc',
      8: '#808080',
      9: '#c0c0c0'
    };
    const COLOR_NAME_MAP = {
      'red': '#ef4444',
      'yellow': '#facc15',
      'green': '#22c55e',
      'cyan': '#14b8a6',
      'blue': '#3b82f6',
      'magenta': '#d946ef',
      'purple': '#8b5cf6',
      'white': '#f8fafc',
      'black': '#1e293b',
      'gray': '#94a3b8',
      'grey': '#94a3b8',
      'light gray': '#cbd5f5',
      'light grey': '#cbd5f5',
      'dark gray': '#475569',
      'dark grey': '#475569',
      'orange': '#fb923c'
    };

    const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

    function componentToHex(value) {
      return clamp(Math.round(value), 0, 255).toString(16).padStart(2, '0');
    }

    function rgbStringToHex(str) {
      if (!str || typeof str !== 'string') return null;
      const trimmed = str.trim();
      if (trimmed.startsWith('#') && (trimmed.length === 7 || trimmed.length === 4)) {
        return trimmed.length === 4
          ? '#' + trimmed.slice(1).split('').map(ch => ch + ch).join('')
          : trimmed;
      }
      const parts = trimmed.split(/[^0-9]+/).filter(Boolean).slice(0, 3).map(Number);
      if (parts.length !== 3 || parts.some(isNaN)) return null;
      const [r, g, b] = parts.map(v => clamp(v, 0, 255));
      return `#${componentToHex(r)}${componentToHex(g)}${componentToHex(b)}`;
    }

    function aciToHex(index) {
      const idx = Number(index);
      if (!Number.isFinite(idx)) return null;
      if (ACI_COLORS[idx]) return ACI_COLORS[idx];
      const r = (37 * idx + 73) % 256;
      const g = (17 * idx + 199) % 256;
      const b = (97 * idx + 151) % 256;
      return `#${componentToHex(r)}${componentToHex(g)}${componentToHex(b)}`;
    }

    function hexToRgb(hex) {
      if (!hex || typeof hex !== 'string' || !hex.startsWith('#')) return null;
      const clean = hex.replace('#', '');
      if (clean.length !== 6) return null;
      const intVal = parseInt(clean, 16);
      return {
        r: (intVal >> 16) & 255,
        g: (intVal >> 8) & 255,
        b: intVal & 255
      };
    }

    function hexToRgba(hex, alpha = DEFAULT_FILL_ALPHA) {
      const rgb = hexToRgb(hex);
      if (!rgb) return `rgba(34,211,238,${alpha})`;
      return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
    }

    function ensureVisibleStroke(hex) {
      const rgb = hexToRgb(hex);
      if (!rgb) return hex || DEFAULT_COLOR;
      const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
      if (luminance > 0.85) {
        return '#64748b';
      }
      return hex;
    }

    const Legend = ({ items }) => {
      if (!items || !items.length) return null;
      return React.createElement(
        'div',
        { className: 'map-legend' },
        [
          React.createElement('h4', { key: 'legend-title' }, 'Legend'),
          ...items.map(item =>
            React.createElement(
              'div',
              { className: 'legend-item', key: item.key || item.label },
              [
                React.createElement('span', {
                  key: 'swatch',
                  className: 'legend-swatch',
                  style: { background: item.fill, borderColor: item.stroke }
                }),
                React.createElement(
                  'div',
                  { key: 'label', className: 'legend-label' },
                  [
                    React.createElement('div', { key: 'label-line' }, item.label),
                    item.subtitle
                      ? React.createElement('div', { key: 'sub', className: 'legend-muted' }, item.subtitle)
                      : null
                  ]
                )
              ]
            )
          )
        ]
      );
    };

    function MapViewer() {
      const mapRef = useRef(null);
      const mapEl = useRef(null);
      const [ready, setReady] = useState(false);
      const [projects, setProjects] = useState([]);
      const [drawings, setDrawings] = useState([]);
      const [projectId, setProjectId] = useState('');
      const [drawingId, setDrawingId] = useState('');
      const [mousePos, setMousePos] = useState({ lat: 0, lng: 0 });
      const [zoom, setZoom] = useState(12);
      const [featureSummary, setFeatureSummary] = useState({ count: 0, source: null });
      const [loadingGeojson, setLoadingGeojson] = useState(false);
      const [legendItems, setLegendItems] = useState([]);
      const apiClient = window.API || { list: async () => [], request: async () => ({}) };
      const locate = useRef({ marker: null, circle: null });
      const featureLayer = useRef(null);

      const resolveLayerColors = useCallback((props = {}) => {
        const rgbHex = rgbStringToHex(props.layer_color_rgb);
        const colorName = typeof props.layer_color_name === 'string'
          ? COLOR_NAME_MAP[props.layer_color_name.toLowerCase()]
          : null;
        let idxValue = null;
        if (props.layer_color_index !== undefined && props.layer_color_index !== null && props.layer_color_index !== '') {
          const parsed = Number(props.layer_color_index);
          idxValue = Number.isFinite(parsed) ? parsed : null;
        }

        let stroke = rgbHex || (idxValue !== null ? aciToHex(idxValue) : null) || colorName || DEFAULT_COLOR;
        stroke = ensureVisibleStroke(stroke);
        const fill = hexToRgba(stroke, DEFAULT_FILL_ALPHA);
        const label = props.layer_name || props.feature_type || 'Layer';
        const subtitle = props.layer_color_name
          ? props.layer_color_name
          : (idxValue !== null ? `ACI ${idxValue}` : null);

        return { stroke, fill, label, subtitle };
      }, []);

      useEffect(() => {
        if (mapRef.current) return; // already init

        // Basemaps
        const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 23, attribution: '&copy; OpenStreetMap'
        });
        const esri = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
          maxZoom: 23, attribution: '&copy; Esri, Maxar, Earthstar Geographics'
        });
        const carto = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
          maxZoom: 23, attribution: '&copy; CARTO'
        });
        const parcels = L.tileLayer.wms(
          'https://gis.sonomacounty.org/arcgis/services/BaseMaps/Parcels/MapServer/WMSServer',
          {
            layers: '0',
            format: 'image/png',
            transparent: true,
            opacity: 0.55,
            attribution: 'Sonoma County GIS'
          }
        );
        const baseLayers = {
          'OSM': osm,
          'Esri Imagery': esri,
          'CARTO Voyager': carto
        };
        const overlayLayers = {
          'Parcels (Sonoma County)': parcels
        };

        const map = L.map(mapEl.current, {
          center: [38.4405, -122.7144], // Santa Rosa, CA default
          zoom: 12,
          zoomControl: false,
          layers: [osm],
          zoomSnap: 0.25,
          zoomDelta: 0.25,
          wheelPxPerZoomLevel: 90
        });
        map.setMinZoom(8);
        map.setMaxZoom(23);
        L.control.zoom({ position: 'topright' }).addTo(map);
        L.control.scale().addTo(map);
        L.control.layers(baseLayers, overlayLayers, { position: 'topright', collapsed: true }).addTo(map);

        mapRef.current = map;
        map.on('mousemove', (e) => setMousePos({ lat: e.latlng.lat, lng: e.latlng.lng }));
        map.on('zoomend', () => setZoom(map.getZoom()));
        setReady(true);
      }, []);

      // Load projects
      useEffect(() => {
        (async () => {
          try { setProjects(await apiClient.list('/projects')); }
          catch (e) { console.warn('Failed to load projects', e); }
        })();
      }, []);

      // Load drawings when project changes
      useEffect(() => {
        if (!projectId) { setDrawings([]); setDrawingId(''); return; }
        (async () => {
          try { setDrawings(await apiClient.list(`/projects/${projectId}/drawings`)); }
          catch (e) { console.warn('Failed to load drawings', e); setDrawings([]); }
        })();
      }, [projectId]);

      // Load extent + GeoJSON overlay when drawing changes
      useEffect(() => {
        const map = mapRef.current;
        if (!map) return;

        let cancelled = false;
        const clearLayer = () => {
          if (featureLayer.current) {
            map.removeLayer(featureLayer.current);
            featureLayer.current = null;
          }
          setLegendItems([]);
        };

        if (!drawingId) {
          clearLayer();
          setFeatureSummary({ count: 0, source: null });
          setLoadingGeojson(false);
          return;
        }

        setLoadingGeojson(true);
        setFeatureSummary({ count: 0, source: null });

        (async () => {
          try {
            const extent = await apiClient.request('GET', `/drawings/${drawingId}/extent?srid=4326`);
            if (!cancelled && extent && extent.bounds) {
              const epsg = extent.stats?.source === 'block_inserts'
                ? (extent.drawing_epsg_code || 'EPSG:4326')
                : 'EPSG:4326';
              const b = extent.bounds;
              const ll = transformToLatLng([b.min_x, b.min_y], epsg);
              const ur = transformToLatLng([b.max_x, b.max_y], epsg);
              const sw = L.latLng(ll.lat, ll.lng);
              const ne = L.latLng(ur.lat, ur.lng);
              if (sw && ne && sw.lat !== ne.lat && sw.lng !== ne.lng) {
                map.fitBounds(L.latLngBounds(sw, ne), { padding: [30, 30] });
              }
            }
          } catch (err) {
            console.warn('Failed to get drawing bounds', err);
          }

          try {
            const geo = await apiClient.request('GET', `/drawings/${drawingId}/geojson?limit=5000`);
            if (cancelled) return;

            clearLayer();
            if (geo && geo.features && geo.features.length) {
              featureLayer.current = L.geoJSON(geo, {
                style: geoJsonStyle,
                pointToLayer: geoJsonPoint,
                onEachFeature: geoJsonOnEach
              }).addTo(map);

              const layerBounds = featureLayer.current.getBounds();
              if (layerBounds && layerBounds.isValid()) {
                map.fitBounds(layerBounds.pad(0.05), { padding: [20, 20] });
              }

              const legendMap = new Map();
              geo.features.forEach((feature) => {
                const props = feature?.properties || {};
                const colors = resolveLayerColors(props);
                const key = props.layer_name || props.feature_type || `layer-${legendMap.size}`;
                if (!legendMap.has(key)) {
                  legendMap.set(key, {
                    key,
                    label: colors.label,
                    subtitle: colors.subtitle,
                    stroke: colors.stroke,
                    fill: colors.fill
                  });
                }
              });
              setLegendItems(Array.from(legendMap.values()));
            } else {
              setLegendItems([]);
            }

            setFeatureSummary({
              count: geo?.count || (geo?.features ? geo.features.length : 0),
              source: geo?.source || 'canonical_features',
              srid: geo?.srid || 4326
            });
          } catch (err) {
            if (!cancelled) {
              console.warn('Failed to load drawing GeoJSON', err);
              setFeatureSummary({ count: 0, source: null, error: err?.message || 'GeoJSON load failed' });
              clearLayer();
            }
          } finally {
            if (!cancelled) setLoadingGeojson(false);
          }
        })();

        return () => { cancelled = true; };
      }, [drawingId, apiClient, geoJsonOnEach, geoJsonPoint, geoJsonStyle, resolveLayerColors]);

      function transformToLatLng([x, y], fromEpsg) {
        try {
          ensureEpsg(fromEpsg);
          const out = proj4(fromEpsg, 'EPSG:4326', [x, y]);
          return { lat: out[1], lng: out[0] };
        } catch (e) {
          return { lat: y, lng: x };
        }
      }

      function ensureEpsg(code) {
        if (!code || code === 'EPSG:4326' || code === 'EPSG:3857') return;
        if (proj4 && !proj4.defs[code]) {
          if (code === 'EPSG:2226') {
            proj4.defs('EPSG:2226', '+proj=lcc +lat_1=39.83333333333334 +lat_2=38.33333333333334 +lat_0=37.66666666666666 +lon_0=-122 +x_0=6561666.666666666 +y_0=1640416.666666667 +datum=NAD83 +units=us-ft +no_defs');
          }
        }
      }

      const geoJsonStyle = useCallback((feature) => {
        const props = feature?.properties || {};
        const colors = resolveLayerColors(props);
        const geomType = (feature?.geometry?.type || '').toLowerCase();
        const base =
          geomType.includes('polygon') ? FEATURE_STYLE.polygon :
          geomType.includes('line') ? FEATURE_STYLE.line :
          FEATURE_STYLE.line;
        return {
          color: colors.stroke,
          weight: base.weight || 2,
          opacity: base.opacity ?? 1,
          fillColor: colors.fill,
          fillOpacity: base.fillOpacity ?? (geomType.includes('polygon') ? DEFAULT_FILL_ALPHA : 0)
        };
      }, [resolveLayerColors]);

      const geoJsonPoint = useCallback((feature, latlng) => {
        const props = feature?.properties || {};
        const colors = resolveLayerColors(props);
        const style = FEATURE_STYLE.point;
        return L.circleMarker(latlng, {
          radius: style.radius || 4,
          color: colors.stroke,
          fillColor: colors.fill,
          fillOpacity: 0.9,
          weight: 1
        });
      }, [resolveLayerColors]);

      const geoJsonOnEach = useCallback((feature, layer) => {
        const props = feature?.properties || {};
        const lines = [];
        if (props.layer_name) lines.push(`<strong>${props.layer_name}</strong>`);
        if (props.feature_type) lines.push(`Type: ${props.feature_type}`);
        if (props.layer_color_name) {
          lines.push(`Color: ${props.layer_color_name}`);
        } else if (props.layer_color_index !== undefined && props.layer_color_index !== null) {
          lines.push(`Color index: ${props.layer_color_index}`);
        }
        if (props.metadata?.block_name) lines.push(`Block: ${props.metadata.block_name}`);
        if (props.metadata?.text) lines.push(props.metadata.text);
        if (lines.length) layer.bindPopup(lines.join('<br/>'));
      }, []);

      function doLocate() {
        const map = mapRef.current; if (!map) return;
        map.locate({ setView: false, watch: false, enableHighAccuracy: true })
          .on('locationfound', (e) => {
            if (locate.current.marker) { map.removeLayer(locate.current.marker); }
            if (locate.current.circle) { map.removeLayer(locate.current.circle); }
            locate.current.marker = L.marker(e.latlng).addTo(map);
            locate.current.circle = L.circle(e.latlng, { radius: e.accuracy, color: '#3b82f6' }).addTo(map);
            map.panTo(e.latlng);
          })
          .on('locationerror', (err) => console.warn('Geolocation error', err));
      }

      return (
        React.createElement('div', { className: 'page-wrapper' },
          React.createElement(HeaderComp, { title: 'Map Viewer', subtitle: 'Leaflet map with basemaps' }),
          React.createElement('main', { className: 'main-content' },
            React.createElement('div', { className: 'container' },
              React.createElement('div', { className: 'card mb-lg' },
                React.createElement('div', { className: 'card-header' },
                  React.createElement('div', { className: 'toolbar' },
                    React.createElement('select', { className: 'input', value: projectId, onChange: (e) => setProjectId(e.target.value) },
                      React.createElement('option', { value: '' }, 'Select project…'),
                      projects.map(p => React.createElement('option', { key: p.project_id, value: p.project_id }, `${p.project_number || '—'} — ${p.project_name}`))
                    ),
                    React.createElement('select', { className: 'input', value: drawingId, onChange: (e) => setDrawingId(e.target.value), disabled: !projectId },
                      React.createElement('option', { value: '' }, projectId ? 'Select drawing…' : 'Select project first'),
                      drawings.map(d => React.createElement('option', { key: d.drawing_id, value: d.drawing_id }, `${d.drawing_number || '—'} — ${d.drawing_name}`))
                    ),
                    React.createElement('span', { className: 'sep' }),
                    React.createElement('button', { className: 'btn btn-secondary', onClick: doLocate },
                      React.createElement('i', { className: 'fas fa-location-crosshairs' }), ' Locate'
                    )
                  )
                )
              ),
              React.createElement('div', { className: 'card' },
                React.createElement('div', { className: 'card-body' },
                  React.createElement('div', { className: 'map-wrapper' },
                    React.createElement('div', { id: 'map', ref: mapEl }),
                    legendItems.length
                      ? React.createElement(Legend, { items: legendItems })
                      : null
                  )
                ),
                React.createElement('div', { className: 'card-footer' },
                  React.createElement('div', { className: 'statusbar' },
                    React.createElement('div', null, `Lat: ${mousePos.lat.toFixed(6)}  Lng: ${mousePos.lng.toFixed(6)}`),
                    React.createElement('div', null, `Zoom: ${zoom.toFixed ? zoom.toFixed(2) : zoom}`),
                    React.createElement('div', null,
                      loadingGeojson
                        ? 'Features: loading…'
                        : featureSummary.error
                          ? `Features: ${featureSummary.error}`
                          : `Features: ${featureSummary.count} (${featureSummary.source || '—'}, EPSG:${featureSummary.srid || '4326'})`
                    )
                  )
                )
              )
            )
          )
        )
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(React.createElement(MapViewer));
  </script>
</body>
</html>
